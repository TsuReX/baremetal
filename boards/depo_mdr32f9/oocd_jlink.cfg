source [find interface/jlink.cfg]
transport select swd
source [find target/stm32f1x.cfg]

proc load_prog {programmer_image_file programmer_ram_addr programmer_entry_point firmware_image_file} {

	# RAM base 
	set ram_base			0x20000000;
	# RAM size 32kb
	set ram_size			0x00008000;
	# RAM base + 8Kb
	set firmware_ram_addr		0x20002000;
	set firmware_rom_addr		0x00000000;
	# TODO: Evaluate image size
	set firmware_image_size		0x00004000; # 16Kb
	# Stack top in RAM
	set programmer_stack_ram_addr	0x20007FF0;
	# Addres of flashing operation status value
	set op_status			0x20000800;

	# Fill the RAM with zeros
	mwb $ram_base 0x00 $ram_size

	# Load programmer into the RAM
	load_image $programmer_image_file $programmer_ram_addr

	echo "Fill firmware's RAM with magic value"
	mwb $firmware_ram_addr 0xA5 $firmware_image_size

	# Load firmware image into the RAM
	load_image $firmware_image_file $firmware_ram_addr

	# Set arguments for loader
	reg r0 $firmware_ram_addr
	reg r1 $firmware_rom_addr
	reg r2 $firmware_image_size

	# Set programmer entry point and stack base
	reg pc $programmer_entry_point
	reg sp $programmer_stack_ram_addr

	# Run loader
	resume

	# TODO Waiting time must be depenent of loading completion
	sleep 3000
#	mdw 0x00007000 1
#	mdw 0x00008000 1
#	mdw 0x00009000 1
#	mdw 0x0000A000 1
	echo "Flash programming status"
	mdw $op_status

	# At this point MCU should be reset and run program from flash
	halt
	exit
}

add_usage_text load_prog "programmer_image_file programmer_ram_addr programmer_entry_point firmware_image_file"
add_help_text load_prog "Loading flash programmer into memory"

proc do {action} {
	echo "ECHO $action"
	if {$action=="debug"} {
		init
		reset halt

	} elseif {$action=="flash"} {
		init
		reset halt
		load_prog fprog.bin 0x20000000 0x20000000 depo_mdr32f9.bin
	} else {
		init
		echo "Select action: debug or flash"
		exit
	}
}

add_usage_text do "action"
add_help_text do "Select action to do: debug, flash."